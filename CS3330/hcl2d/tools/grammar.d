/**
 * This file was auto-generated by PEGGED, which is available under the Boost
 * license from <https://github.com/PhilippeSigaud/Pegged>.
 * The originating PEGGED grammar follows this comment.
 * 
 * The grammar and this file are both part of the HCL2D project, which is a
 * a hardware description language inspired by the HCL language described in 
 * Computer Systems: A Programmer's Perspective by R. Bryant and D. O'Hallaron.
 * 
 * License:
 * Copyright (c) 2015 Luther Tychonievich. 
 * Released into the public domain.  
 * Attribution is appreciated but not required.
 */
/+

HCL:
	DefList < ((ConstDef / WireDef / Initialize / RegDef / ';')* eoi) { flatten }
	
	Comment1 <- '#' (!eol .)* (eol / eoi)
	Comment2 <- '//' (!eol .)* (eol / eoi)
	Comment3 <- '/*' (!'*' . / '*' !'/')* '*/'
	Spacing <- ((blank / Comment1 / Comment2 / Comment3)*)
	
	Math <- SetMembership / Math1 / MuxExp
	Math1 < (Math2 (BinOp Math2)*)
	Math2 < UnOp* Math3
	Math3 <- WireCat / Slice
	WireCat < '(' Slice ('..' Slice)+ ')'
	Slice < Value ('[' DecLit '..' DecLit ']')?
	Value <- (BinLit / HexLit / DecLit / BoolLit / Variable) ![0-9a-zA-Z] / '(' Math ')'
	BinLit <- "0b" ~([01]+)
	HexLit <- "0x" ~([0-9a-fA-F]+) 
	DecLit <- ~([1-9] [0-9]* / "0" ![0-9])
	BoolLit <- 'true' / 'True' / 'TRUE' / 'false' / 'False' / 'FALSE'
	Variable <- identifier
	BinOp <- 
		/ '<=' / '==' / '>=' / '!=' / '<' / '>'
		/ '||' / '&&' / '|' / '&' / '^'
		/ '+' / '-' / '*' / '/' / '%'
	UnOp <- '~' / '-' / '!'
	
	MuxExp < '[' MuxRow+ ']'
	MuxRow < (SetMembership / Math1) ':' Math ';'
	
	SetMembership < (Math1 'in' '{' Math (',' Math)* '}') { setToOr }
	
	ConstDef < "const" :spacing Variable "=" Math1 (',' Variable '=' Math1)* ';'
	WireDef < "wire" :spacing Variable ':' DecLit (',' Variable ':' DecLit)* ';'
	Initialize < Variable '=' Math (',' Variable '=' Math)* ';'
	RegDef < 'register' :spacing ~([a-z]? [A-Z]) '{' RegPart* '}'
	RegPart < Variable ':' DecLit '=' Math ';'

+/
import pegged.grammar;

struct GenericHCL(TParseTree)
{
	import std.functional : toDelegate;
    import pegged.dynamic.grammar;
	static import pegged.peg;
    struct HCL
    {
    enum name = "HCL";
    static ParseTree delegate(ParseTree)[string] before;
    static ParseTree delegate(ParseTree)[string] after;
    static ParseTree delegate(ParseTree)[string] rules;
    import std.typecons:Tuple, tuple;
    static TParseTree[Tuple!(string, size_t)] memo;
    static this()
    {
        rules["DefList"] = toDelegate(&DefList);
        rules["Comment1"] = toDelegate(&Comment1);
        rules["Comment2"] = toDelegate(&Comment2);
        rules["Comment3"] = toDelegate(&Comment3);
        rules["Spacing"] = toDelegate(&Spacing);
    }

    template hooked(alias r, string name)
    {
        static ParseTree hooked(ParseTree p)
        {
            ParseTree result;

            if (name in before)
            {
                result = before[name](p);
                if (result.successful)
                    return result;
            }

            result = r(p);
            if (result.successful || name !in after)
                return result;

            result = after[name](p);
            return result;
        }

        static ParseTree hooked(string input)
        {
            return hooked!(r, name)(ParseTree("",false,[],input));
        }
    }

    static void addRuleBefore(string parentRule, string ruleSyntax)
    {
        // enum name is the current grammar name
        DynamicGrammar dg = pegged.dynamic.grammar.grammar(name ~ ": " ~ ruleSyntax, rules);
        foreach(ruleName,rule; dg.rules)
            if (ruleName != "Spacing") // Keep the local Spacing rule, do not overwrite it
                rules[ruleName] = rule;
        before[parentRule] = rules[dg.startingRule];
    }

    static void addRuleAfter(string parentRule, string ruleSyntax)
    {
        // enum name is the current grammar named
        DynamicGrammar dg = pegged.dynamic.grammar.grammar(name ~ ": " ~ ruleSyntax, rules);
        foreach(name,rule; dg.rules)
        {
            if (name != "Spacing")
                rules[name] = rule;
        }
        after[parentRule] = rules[dg.startingRule];
    }

    static bool isRule(string s)
    {
		import std.algorithm : startsWith;
        return s.startsWith("HCL.");
    }
    mixin decimateTree;

    static TParseTree DefList(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.action!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.or!(pegged.peg.wrapAround!(Spacing, ConstDef, Spacing), pegged.peg.wrapAround!(Spacing, WireDef, Spacing), pegged.peg.wrapAround!(Spacing, Initialize, Spacing), pegged.peg.wrapAround!(Spacing, RegDef, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, eoi, Spacing)), Spacing), flatten ), "HCL.DefList")(p);
        }
        else
        {
            if (auto m = tuple(`DefList`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.action!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.or!(pegged.peg.wrapAround!(Spacing, ConstDef, Spacing), pegged.peg.wrapAround!(Spacing, WireDef, Spacing), pegged.peg.wrapAround!(Spacing, Initialize, Spacing), pegged.peg.wrapAround!(Spacing, RegDef, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, eoi, Spacing)), Spacing), flatten ), "HCL.DefList"), "DefList")(p);
                memo[tuple(`DefList`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree DefList(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.action!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.or!(pegged.peg.wrapAround!(Spacing, ConstDef, Spacing), pegged.peg.wrapAround!(Spacing, WireDef, Spacing), pegged.peg.wrapAround!(Spacing, Initialize, Spacing), pegged.peg.wrapAround!(Spacing, RegDef, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, eoi, Spacing)), Spacing), flatten ), "HCL.DefList")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.action!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.or!(pegged.peg.wrapAround!(Spacing, ConstDef, Spacing), pegged.peg.wrapAround!(Spacing, WireDef, Spacing), pegged.peg.wrapAround!(Spacing, Initialize, Spacing), pegged.peg.wrapAround!(Spacing, RegDef, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, eoi, Spacing)), Spacing), flatten ), "HCL.DefList"), "DefList")(TParseTree("", false,[], s));
        }
    }
    static string DefList(GetName g)
    {
        return "HCL.DefList";
    }

    static TParseTree Comment1(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("#"), pegged.peg.zeroOrMore!(pegged.peg.and!(pegged.peg.negLookahead!(eol), pegged.peg.any)), pegged.peg.or!(eol, eoi)), "HCL.Comment1")(p);
        }
        else
        {
            if (auto m = tuple(`Comment1`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("#"), pegged.peg.zeroOrMore!(pegged.peg.and!(pegged.peg.negLookahead!(eol), pegged.peg.any)), pegged.peg.or!(eol, eoi)), "HCL.Comment1"), "Comment1")(p);
                memo[tuple(`Comment1`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Comment1(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("#"), pegged.peg.zeroOrMore!(pegged.peg.and!(pegged.peg.negLookahead!(eol), pegged.peg.any)), pegged.peg.or!(eol, eoi)), "HCL.Comment1")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("#"), pegged.peg.zeroOrMore!(pegged.peg.and!(pegged.peg.negLookahead!(eol), pegged.peg.any)), pegged.peg.or!(eol, eoi)), "HCL.Comment1"), "Comment1")(TParseTree("", false,[], s));
        }
    }
    static string Comment1(GetName g)
    {
        return "HCL.Comment1";
    }

    static TParseTree Comment2(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("//"), pegged.peg.zeroOrMore!(pegged.peg.and!(pegged.peg.negLookahead!(eol), pegged.peg.any)), pegged.peg.or!(eol, eoi)), "HCL.Comment2")(p);
        }
        else
        {
            if (auto m = tuple(`Comment2`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("//"), pegged.peg.zeroOrMore!(pegged.peg.and!(pegged.peg.negLookahead!(eol), pegged.peg.any)), pegged.peg.or!(eol, eoi)), "HCL.Comment2"), "Comment2")(p);
                memo[tuple(`Comment2`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Comment2(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("//"), pegged.peg.zeroOrMore!(pegged.peg.and!(pegged.peg.negLookahead!(eol), pegged.peg.any)), pegged.peg.or!(eol, eoi)), "HCL.Comment2")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("//"), pegged.peg.zeroOrMore!(pegged.peg.and!(pegged.peg.negLookahead!(eol), pegged.peg.any)), pegged.peg.or!(eol, eoi)), "HCL.Comment2"), "Comment2")(TParseTree("", false,[], s));
        }
    }
    static string Comment2(GetName g)
    {
        return "HCL.Comment2";
    }

    static TParseTree Comment3(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("/*"), pegged.peg.zeroOrMore!(pegged.peg.or!(pegged.peg.and!(pegged.peg.negLookahead!(pegged.peg.literal!("*")), pegged.peg.any), pegged.peg.and!(pegged.peg.literal!("*"), pegged.peg.negLookahead!(pegged.peg.literal!("/"))))), pegged.peg.literal!("*/")), "HCL.Comment3")(p);
        }
        else
        {
            if (auto m = tuple(`Comment3`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("/*"), pegged.peg.zeroOrMore!(pegged.peg.or!(pegged.peg.and!(pegged.peg.negLookahead!(pegged.peg.literal!("*")), pegged.peg.any), pegged.peg.and!(pegged.peg.literal!("*"), pegged.peg.negLookahead!(pegged.peg.literal!("/"))))), pegged.peg.literal!("*/")), "HCL.Comment3"), "Comment3")(p);
                memo[tuple(`Comment3`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Comment3(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("/*"), pegged.peg.zeroOrMore!(pegged.peg.or!(pegged.peg.and!(pegged.peg.negLookahead!(pegged.peg.literal!("*")), pegged.peg.any), pegged.peg.and!(pegged.peg.literal!("*"), pegged.peg.negLookahead!(pegged.peg.literal!("/"))))), pegged.peg.literal!("*/")), "HCL.Comment3")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("/*"), pegged.peg.zeroOrMore!(pegged.peg.or!(pegged.peg.and!(pegged.peg.negLookahead!(pegged.peg.literal!("*")), pegged.peg.any), pegged.peg.and!(pegged.peg.literal!("*"), pegged.peg.negLookahead!(pegged.peg.literal!("/"))))), pegged.peg.literal!("*/")), "HCL.Comment3"), "Comment3")(TParseTree("", false,[], s));
        }
    }
    static string Comment3(GetName g)
    {
        return "HCL.Comment3";
    }

    static TParseTree Spacing(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.zeroOrMore!(pegged.peg.or!(blank, Comment1, Comment2, Comment3)), "HCL.Spacing")(p);
        }
        else
        {
            if (auto m = tuple(`Spacing`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.zeroOrMore!(pegged.peg.or!(blank, Comment1, Comment2, Comment3)), "HCL.Spacing"), "Spacing")(p);
                memo[tuple(`Spacing`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Spacing(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.zeroOrMore!(pegged.peg.or!(blank, Comment1, Comment2, Comment3)), "HCL.Spacing")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.zeroOrMore!(pegged.peg.or!(blank, Comment1, Comment2, Comment3)), "HCL.Spacing"), "Spacing")(TParseTree("", false,[], s));
        }
    }
    static string Spacing(GetName g)
    {
        return "HCL.Spacing";
    }

    static TParseTree Math(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.or!(SetMembership, Math1, MuxExp), "HCL.Math")(p);
        }
        else
        {
            if (auto m = tuple(`Math`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.or!(SetMembership, Math1, MuxExp), "HCL.Math"), "Math")(p);
                memo[tuple(`Math`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Math(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.or!(SetMembership, Math1, MuxExp), "HCL.Math")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.or!(SetMembership, Math1, MuxExp), "HCL.Math"), "Math")(TParseTree("", false,[], s));
        }
    }
    static string Math(GetName g)
    {
        return "HCL.Math";
    }

    static TParseTree Math1(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Math2, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, BinOp, Spacing), pegged.peg.wrapAround!(Spacing, Math2, Spacing)), Spacing))), Spacing), "HCL.Math1")(p);
        }
        else
        {
            if (auto m = tuple(`Math1`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Math2, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, BinOp, Spacing), pegged.peg.wrapAround!(Spacing, Math2, Spacing)), Spacing))), Spacing), "HCL.Math1"), "Math1")(p);
                memo[tuple(`Math1`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Math1(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Math2, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, BinOp, Spacing), pegged.peg.wrapAround!(Spacing, Math2, Spacing)), Spacing))), Spacing), "HCL.Math1")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Math2, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, BinOp, Spacing), pegged.peg.wrapAround!(Spacing, Math2, Spacing)), Spacing))), Spacing), "HCL.Math1"), "Math1")(TParseTree("", false,[], s));
        }
    }
    static string Math1(GetName g)
    {
        return "HCL.Math1";
    }

    static TParseTree Math2(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, UnOp, Spacing)), pegged.peg.wrapAround!(Spacing, Math3, Spacing)), "HCL.Math2")(p);
        }
        else
        {
            if (auto m = tuple(`Math2`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, UnOp, Spacing)), pegged.peg.wrapAround!(Spacing, Math3, Spacing)), "HCL.Math2"), "Math2")(p);
                memo[tuple(`Math2`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Math2(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, UnOp, Spacing)), pegged.peg.wrapAround!(Spacing, Math3, Spacing)), "HCL.Math2")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, UnOp, Spacing)), pegged.peg.wrapAround!(Spacing, Math3, Spacing)), "HCL.Math2"), "Math2")(TParseTree("", false,[], s));
        }
    }
    static string Math2(GetName g)
    {
        return "HCL.Math2";
    }

    static TParseTree Math3(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.or!(WireCat, Slice), "HCL.Math3")(p);
        }
        else
        {
            if (auto m = tuple(`Math3`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.or!(WireCat, Slice), "HCL.Math3"), "Math3")(p);
                memo[tuple(`Math3`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Math3(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.or!(WireCat, Slice), "HCL.Math3")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.or!(WireCat, Slice), "HCL.Math3"), "Math3")(TParseTree("", false,[], s));
        }
    }
    static string Math3(GetName g)
    {
        return "HCL.Math3";
    }

    static TParseTree WireCat(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("("), Spacing), pegged.peg.wrapAround!(Spacing, Slice, Spacing), pegged.peg.oneOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(".."), Spacing), pegged.peg.wrapAround!(Spacing, Slice, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(")"), Spacing)), "HCL.WireCat")(p);
        }
        else
        {
            if (auto m = tuple(`WireCat`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("("), Spacing), pegged.peg.wrapAround!(Spacing, Slice, Spacing), pegged.peg.oneOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(".."), Spacing), pegged.peg.wrapAround!(Spacing, Slice, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(")"), Spacing)), "HCL.WireCat"), "WireCat")(p);
                memo[tuple(`WireCat`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree WireCat(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("("), Spacing), pegged.peg.wrapAround!(Spacing, Slice, Spacing), pegged.peg.oneOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(".."), Spacing), pegged.peg.wrapAround!(Spacing, Slice, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(")"), Spacing)), "HCL.WireCat")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("("), Spacing), pegged.peg.wrapAround!(Spacing, Slice, Spacing), pegged.peg.oneOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(".."), Spacing), pegged.peg.wrapAround!(Spacing, Slice, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(")"), Spacing)), "HCL.WireCat"), "WireCat")(TParseTree("", false,[], s));
        }
    }
    static string WireCat(GetName g)
    {
        return "HCL.WireCat";
    }

    static TParseTree Slice(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Value, Spacing), pegged.peg.option!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("["), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(".."), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("]"), Spacing)), Spacing))), "HCL.Slice")(p);
        }
        else
        {
            if (auto m = tuple(`Slice`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Value, Spacing), pegged.peg.option!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("["), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(".."), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("]"), Spacing)), Spacing))), "HCL.Slice"), "Slice")(p);
                memo[tuple(`Slice`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Slice(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Value, Spacing), pegged.peg.option!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("["), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(".."), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("]"), Spacing)), Spacing))), "HCL.Slice")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Value, Spacing), pegged.peg.option!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("["), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(".."), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("]"), Spacing)), Spacing))), "HCL.Slice"), "Slice")(TParseTree("", false,[], s));
        }
    }
    static string Slice(GetName g)
    {
        return "HCL.Slice";
    }

    static TParseTree Value(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.or!(pegged.peg.and!(pegged.peg.or!(BinLit, HexLit, DecLit, BoolLit, Variable), pegged.peg.negLookahead!(pegged.peg.or!(pegged.peg.charRange!('0', '9'), pegged.peg.charRange!('a', 'z'), pegged.peg.charRange!('A', 'Z')))), pegged.peg.and!(pegged.peg.literal!("("), Math, pegged.peg.literal!(")"))), "HCL.Value")(p);
        }
        else
        {
            if (auto m = tuple(`Value`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.or!(pegged.peg.and!(pegged.peg.or!(BinLit, HexLit, DecLit, BoolLit, Variable), pegged.peg.negLookahead!(pegged.peg.or!(pegged.peg.charRange!('0', '9'), pegged.peg.charRange!('a', 'z'), pegged.peg.charRange!('A', 'Z')))), pegged.peg.and!(pegged.peg.literal!("("), Math, pegged.peg.literal!(")"))), "HCL.Value"), "Value")(p);
                memo[tuple(`Value`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Value(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.or!(pegged.peg.and!(pegged.peg.or!(BinLit, HexLit, DecLit, BoolLit, Variable), pegged.peg.negLookahead!(pegged.peg.or!(pegged.peg.charRange!('0', '9'), pegged.peg.charRange!('a', 'z'), pegged.peg.charRange!('A', 'Z')))), pegged.peg.and!(pegged.peg.literal!("("), Math, pegged.peg.literal!(")"))), "HCL.Value")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.or!(pegged.peg.and!(pegged.peg.or!(BinLit, HexLit, DecLit, BoolLit, Variable), pegged.peg.negLookahead!(pegged.peg.or!(pegged.peg.charRange!('0', '9'), pegged.peg.charRange!('a', 'z'), pegged.peg.charRange!('A', 'Z')))), pegged.peg.and!(pegged.peg.literal!("("), Math, pegged.peg.literal!(")"))), "HCL.Value"), "Value")(TParseTree("", false,[], s));
        }
    }
    static string Value(GetName g)
    {
        return "HCL.Value";
    }

    static TParseTree BinLit(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("0b"), pegged.peg.fuse!(pegged.peg.oneOrMore!(pegged.peg.or!(pegged.peg.literal!("0"), pegged.peg.literal!("1"))))), "HCL.BinLit")(p);
        }
        else
        {
            if (auto m = tuple(`BinLit`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("0b"), pegged.peg.fuse!(pegged.peg.oneOrMore!(pegged.peg.or!(pegged.peg.literal!("0"), pegged.peg.literal!("1"))))), "HCL.BinLit"), "BinLit")(p);
                memo[tuple(`BinLit`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree BinLit(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("0b"), pegged.peg.fuse!(pegged.peg.oneOrMore!(pegged.peg.or!(pegged.peg.literal!("0"), pegged.peg.literal!("1"))))), "HCL.BinLit")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("0b"), pegged.peg.fuse!(pegged.peg.oneOrMore!(pegged.peg.or!(pegged.peg.literal!("0"), pegged.peg.literal!("1"))))), "HCL.BinLit"), "BinLit")(TParseTree("", false,[], s));
        }
    }
    static string BinLit(GetName g)
    {
        return "HCL.BinLit";
    }

    static TParseTree HexLit(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("0x"), pegged.peg.fuse!(pegged.peg.oneOrMore!(pegged.peg.or!(pegged.peg.charRange!('0', '9'), pegged.peg.charRange!('a', 'f'), pegged.peg.charRange!('A', 'F'))))), "HCL.HexLit")(p);
        }
        else
        {
            if (auto m = tuple(`HexLit`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("0x"), pegged.peg.fuse!(pegged.peg.oneOrMore!(pegged.peg.or!(pegged.peg.charRange!('0', '9'), pegged.peg.charRange!('a', 'f'), pegged.peg.charRange!('A', 'F'))))), "HCL.HexLit"), "HexLit")(p);
                memo[tuple(`HexLit`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree HexLit(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("0x"), pegged.peg.fuse!(pegged.peg.oneOrMore!(pegged.peg.or!(pegged.peg.charRange!('0', '9'), pegged.peg.charRange!('a', 'f'), pegged.peg.charRange!('A', 'F'))))), "HCL.HexLit")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.literal!("0x"), pegged.peg.fuse!(pegged.peg.oneOrMore!(pegged.peg.or!(pegged.peg.charRange!('0', '9'), pegged.peg.charRange!('a', 'f'), pegged.peg.charRange!('A', 'F'))))), "HCL.HexLit"), "HexLit")(TParseTree("", false,[], s));
        }
    }
    static string HexLit(GetName g)
    {
        return "HCL.HexLit";
    }

    static TParseTree DecLit(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.fuse!(pegged.peg.or!(pegged.peg.and!(pegged.peg.charRange!('1', '9'), pegged.peg.zeroOrMore!(pegged.peg.charRange!('0', '9'))), pegged.peg.and!(pegged.peg.literal!("0"), pegged.peg.negLookahead!(pegged.peg.charRange!('0', '9'))))), "HCL.DecLit")(p);
        }
        else
        {
            if (auto m = tuple(`DecLit`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.fuse!(pegged.peg.or!(pegged.peg.and!(pegged.peg.charRange!('1', '9'), pegged.peg.zeroOrMore!(pegged.peg.charRange!('0', '9'))), pegged.peg.and!(pegged.peg.literal!("0"), pegged.peg.negLookahead!(pegged.peg.charRange!('0', '9'))))), "HCL.DecLit"), "DecLit")(p);
                memo[tuple(`DecLit`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree DecLit(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.fuse!(pegged.peg.or!(pegged.peg.and!(pegged.peg.charRange!('1', '9'), pegged.peg.zeroOrMore!(pegged.peg.charRange!('0', '9'))), pegged.peg.and!(pegged.peg.literal!("0"), pegged.peg.negLookahead!(pegged.peg.charRange!('0', '9'))))), "HCL.DecLit")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.fuse!(pegged.peg.or!(pegged.peg.and!(pegged.peg.charRange!('1', '9'), pegged.peg.zeroOrMore!(pegged.peg.charRange!('0', '9'))), pegged.peg.and!(pegged.peg.literal!("0"), pegged.peg.negLookahead!(pegged.peg.charRange!('0', '9'))))), "HCL.DecLit"), "DecLit")(TParseTree("", false,[], s));
        }
    }
    static string DecLit(GetName g)
    {
        return "HCL.DecLit";
    }

    static TParseTree BoolLit(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.keywords!("true", "True", "TRUE", "false", "False", "FALSE"), "HCL.BoolLit")(p);
        }
        else
        {
            if (auto m = tuple(`BoolLit`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.keywords!("true", "True", "TRUE", "false", "False", "FALSE"), "HCL.BoolLit"), "BoolLit")(p);
                memo[tuple(`BoolLit`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree BoolLit(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.keywords!("true", "True", "TRUE", "false", "False", "FALSE"), "HCL.BoolLit")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.keywords!("true", "True", "TRUE", "false", "False", "FALSE"), "HCL.BoolLit"), "BoolLit")(TParseTree("", false,[], s));
        }
    }
    static string BoolLit(GetName g)
    {
        return "HCL.BoolLit";
    }

    static TParseTree Variable(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(identifier, "HCL.Variable")(p);
        }
        else
        {
            if (auto m = tuple(`Variable`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(identifier, "HCL.Variable"), "Variable")(p);
                memo[tuple(`Variable`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Variable(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(identifier, "HCL.Variable")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(identifier, "HCL.Variable"), "Variable")(TParseTree("", false,[], s));
        }
    }
    static string Variable(GetName g)
    {
        return "HCL.Variable";
    }

    static TParseTree BinOp(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.keywords!("<=", "==", ">=", "!=", "<", ">", "||", "&&", "|", "&", "^", "+", "-", "*", "/", "%"), "HCL.BinOp")(p);
        }
        else
        {
            if (auto m = tuple(`BinOp`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.keywords!("<=", "==", ">=", "!=", "<", ">", "||", "&&", "|", "&", "^", "+", "-", "*", "/", "%"), "HCL.BinOp"), "BinOp")(p);
                memo[tuple(`BinOp`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree BinOp(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.keywords!("<=", "==", ">=", "!=", "<", ">", "||", "&&", "|", "&", "^", "+", "-", "*", "/", "%"), "HCL.BinOp")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.keywords!("<=", "==", ">=", "!=", "<", ">", "||", "&&", "|", "&", "^", "+", "-", "*", "/", "%"), "HCL.BinOp"), "BinOp")(TParseTree("", false,[], s));
        }
    }
    static string BinOp(GetName g)
    {
        return "HCL.BinOp";
    }

    static TParseTree UnOp(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.keywords!("~", "-", "!"), "HCL.UnOp")(p);
        }
        else
        {
            if (auto m = tuple(`UnOp`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.keywords!("~", "-", "!"), "HCL.UnOp"), "UnOp")(p);
                memo[tuple(`UnOp`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree UnOp(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.keywords!("~", "-", "!"), "HCL.UnOp")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.keywords!("~", "-", "!"), "HCL.UnOp"), "UnOp")(TParseTree("", false,[], s));
        }
    }
    static string UnOp(GetName g)
    {
        return "HCL.UnOp";
    }

    static TParseTree MuxExp(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("["), Spacing), pegged.peg.oneOrMore!(pegged.peg.wrapAround!(Spacing, MuxRow, Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("]"), Spacing)), "HCL.MuxExp")(p);
        }
        else
        {
            if (auto m = tuple(`MuxExp`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("["), Spacing), pegged.peg.oneOrMore!(pegged.peg.wrapAround!(Spacing, MuxRow, Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("]"), Spacing)), "HCL.MuxExp"), "MuxExp")(p);
                memo[tuple(`MuxExp`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree MuxExp(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("["), Spacing), pegged.peg.oneOrMore!(pegged.peg.wrapAround!(Spacing, MuxRow, Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("]"), Spacing)), "HCL.MuxExp")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("["), Spacing), pegged.peg.oneOrMore!(pegged.peg.wrapAround!(Spacing, MuxRow, Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("]"), Spacing)), "HCL.MuxExp"), "MuxExp")(TParseTree("", false,[], s));
        }
    }
    static string MuxExp(GetName g)
    {
        return "HCL.MuxExp";
    }

    static TParseTree MuxRow(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.or!(pegged.peg.wrapAround!(Spacing, SetMembership, Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing)), Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.MuxRow")(p);
        }
        else
        {
            if (auto m = tuple(`MuxRow`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.or!(pegged.peg.wrapAround!(Spacing, SetMembership, Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing)), Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.MuxRow"), "MuxRow")(p);
                memo[tuple(`MuxRow`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree MuxRow(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.or!(pegged.peg.wrapAround!(Spacing, SetMembership, Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing)), Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.MuxRow")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.or!(pegged.peg.wrapAround!(Spacing, SetMembership, Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing)), Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.MuxRow"), "MuxRow")(TParseTree("", false,[], s));
        }
    }
    static string MuxRow(GetName g)
    {
        return "HCL.MuxRow";
    }

    static TParseTree SetMembership(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.action!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Math1, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("in"), Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("{"), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("}"), Spacing)), Spacing), setToOr ), "HCL.SetMembership")(p);
        }
        else
        {
            if (auto m = tuple(`SetMembership`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.action!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Math1, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("in"), Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("{"), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("}"), Spacing)), Spacing), setToOr ), "HCL.SetMembership"), "SetMembership")(p);
                memo[tuple(`SetMembership`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree SetMembership(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.action!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Math1, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("in"), Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("{"), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("}"), Spacing)), Spacing), setToOr ), "HCL.SetMembership")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.action!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Math1, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("in"), Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("{"), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("}"), Spacing)), Spacing), setToOr ), "HCL.SetMembership"), "SetMembership")(TParseTree("", false,[], s));
        }
    }
    static string SetMembership(GetName g)
    {
        return "HCL.SetMembership";
    }

    static TParseTree ConstDef(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("const"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.ConstDef")(p);
        }
        else
        {
            if (auto m = tuple(`ConstDef`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("const"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.ConstDef"), "ConstDef")(p);
                memo[tuple(`ConstDef`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree ConstDef(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("const"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.ConstDef")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("const"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math1, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.ConstDef"), "ConstDef")(TParseTree("", false,[], s));
        }
    }
    static string ConstDef(GetName g)
    {
        return "HCL.ConstDef";
    }

    static TParseTree WireDef(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("wire"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.WireDef")(p);
        }
        else
        {
            if (auto m = tuple(`WireDef`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("wire"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.WireDef"), "WireDef")(p);
                memo[tuple(`WireDef`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree WireDef(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("wire"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.WireDef")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("wire"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.WireDef"), "WireDef")(TParseTree("", false,[], s));
        }
    }
    static string WireDef(GetName g)
    {
        return "HCL.WireDef";
    }

    static TParseTree Initialize(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.Initialize")(p);
        }
        else
        {
            if (auto m = tuple(`Initialize`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.Initialize"), "Initialize")(p);
                memo[tuple(`Initialize`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree Initialize(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.Initialize")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(","), Spacing), pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.Initialize"), "Initialize")(TParseTree("", false,[], s));
        }
    }
    static string Initialize(GetName g)
    {
        return "HCL.Initialize";
    }

    static TParseTree RegDef(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("register"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.fuse!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.option!(pegged.peg.wrapAround!(Spacing, pegged.peg.charRange!('a', 'z'), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.charRange!('A', 'Z'), Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("{"), Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, RegPart, Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("}"), Spacing)), "HCL.RegDef")(p);
        }
        else
        {
            if (auto m = tuple(`RegDef`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("register"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.fuse!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.option!(pegged.peg.wrapAround!(Spacing, pegged.peg.charRange!('a', 'z'), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.charRange!('A', 'Z'), Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("{"), Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, RegPart, Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("}"), Spacing)), "HCL.RegDef"), "RegDef")(p);
                memo[tuple(`RegDef`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree RegDef(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("register"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.fuse!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.option!(pegged.peg.wrapAround!(Spacing, pegged.peg.charRange!('a', 'z'), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.charRange!('A', 'Z'), Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("{"), Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, RegPart, Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("}"), Spacing)), "HCL.RegDef")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("register"), Spacing), pegged.peg.discard!(pegged.peg.wrapAround!(Spacing, spacing, Spacing)), pegged.peg.fuse!(pegged.peg.wrapAround!(Spacing, pegged.peg.and!(pegged.peg.option!(pegged.peg.wrapAround!(Spacing, pegged.peg.charRange!('a', 'z'), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.charRange!('A', 'Z'), Spacing)), Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("{"), Spacing), pegged.peg.zeroOrMore!(pegged.peg.wrapAround!(Spacing, RegPart, Spacing)), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("}"), Spacing)), "HCL.RegDef"), "RegDef")(TParseTree("", false,[], s));
        }
    }
    static string RegDef(GetName g)
    {
        return "HCL.RegDef";
    }

    static TParseTree RegPart(TParseTree p)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.RegPart")(p);
        }
        else
        {
            if (auto m = tuple(`RegPart`, p.end) in memo)
                return *m;
            else
            {
                TParseTree result = hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.RegPart"), "RegPart")(p);
                memo[tuple(`RegPart`, p.end)] = result;
                return result;
            }
        }
    }

    static TParseTree RegPart(string s)
    {
        if(__ctfe)
        {
            return         pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.RegPart")(TParseTree("", false,[], s));
        }
        else
        {
            forgetMemo();
            return hooked!(pegged.peg.defined!(pegged.peg.and!(pegged.peg.wrapAround!(Spacing, Variable, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(":"), Spacing), pegged.peg.wrapAround!(Spacing, DecLit, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!("="), Spacing), pegged.peg.wrapAround!(Spacing, Math, Spacing), pegged.peg.wrapAround!(Spacing, pegged.peg.literal!(";"), Spacing)), "HCL.RegPart"), "RegPart")(TParseTree("", false,[], s));
        }
    }
    static string RegPart(GetName g)
    {
        return "HCL.RegPart";
    }

    static TParseTree opCall(TParseTree p)
    {
        TParseTree result = decimateTree(DefList(p));
        result.children = [result];
        result.name = "HCL";
        return result;
    }

    static TParseTree opCall(string input)
    {
        if(__ctfe)
        {
            return HCL(TParseTree(``, false, [], input, 0, 0));
        }
        else
        {
            forgetMemo();
            return HCL(TParseTree(``, false, [], input, 0, 0));
        }
    }
    static string opCall(GetName g)
    {
        return "HCL";
    }


    static void forgetMemo()
    {
        memo = null;
    }
    }
}

alias GenericHCL!(ParseTree).HCL HCL;



/// A helper function: removes all nodes that are nothing but a single child
ParseTree flatten(ParseTree p) {
	p = HCL.decimateTree(p);
	if (p.children.length == 1 && p.matches == p.children[0].matches) 
		return flatten(p.children[0]);
	auto ans = p;
	foreach(i,c; p.children) {
		ans.children[i] = flatten(c);
	}
	return ans;
}

/// A simplifying function: changes "x in {a,b}" into "x==a||x==b"
ParseTree setToOr(ParseTree p) {
	if (!p.successful) return p;
	p = HCL.decimateTree(p);
	ParseTree ans = {"HCL.Math1", true, p.matches, p.input, p.begin, p.end, []};
	ParseTree eq = {"HCL.BinOp", true, ["=="], p.input, p.children[0].end, p.children[1].begin, []};
	foreach(i, child; p.children[1..$]) {
		if (i > 0) {
			ParseTree or = {"HCL.BinOp", true, ["||"], p.input, p.children[i].end, p.children[i+1].begin, []};
			ans.children ~= or;
		}
		ParseTree term = {"HCL.Math1", true, 
				p.children[0].matches ~ child.matches,
				p.input,
				child.begin, child.end,
				[p.children[0], eq, child] 
			};
		ParseTree wrap = {"HCL.Value", true, 
				"(" ~ term.matches ~ ")",
				p.input,
				term.begin, term.end,
				[term] 
			};
		ans.children ~= wrap;
	}
	return ans;
}
