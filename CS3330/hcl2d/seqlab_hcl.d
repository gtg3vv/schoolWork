// auto-generated HCL2 simulator; DO NOT EDIT THIS FILE
/+++++++++++++++++ generated from the following HCL: ++++++++++++++++++
###################### begin builtin signals ##########################

### constants:

const STAT_BUB = 0b000, STAT_AOK = 0b001, STAT_HLT = 0b010;  # expected behavior
const STAT_ADR = 0b011, STAT_INS = 0b100, STAT_PIP = 0b110;  # error conditions

const REG_RAX = 0b0000, REG_RCX = 0b0001, REG_RDX = 0b0010, REG_RBX = 0b0011;
const REG_RSP = 0b0100, REG_RBP = 0b0101, REG_RSI = 0b0110, REG_RDI = 0b0111;
const REG_R8  = 0b1000, REG_R9  = 0b1001, REG_R10 = 0b1010, REG_R11 = 0b1011;
const REG_R12 = 0b1100, REG_R13 = 0b1101, REG_R14 = 0b1110, REG_NONE= 0b1111;

# icodes; see figure 4.2
const HALT   = 0b0000, NOP    = 0b0001, RRMOVQ = 0b0010, IRMOVQ = 0b0011;
const RMMOVQ = 0b0100, MRMOVQ = 0b0101, OPQ    = 0b0110, JXX    = 0b0111;
const CALL   = 0b1000, RET    = 0b1001, PUSHQ  = 0b1010, POPQ   = 0b1011;
const CMOVXX = RRMOVQ;

# ifuns; see figure 4.3
const ALWAYS = 0b0000, LE   = 0b0001, LT   = 0b0010, EQ   = 0b0011;
const NE     = 0b0100, GE   = 0b0101, GT   = 0b0110;
const ADDQ   = 0b0000, SUBQ = 0b0001, ANDQ = 0b0010, XORQ = 0b0011;


### fixed-functionality inputs (things you should assign to in your HCL)

wire Stat:3;              # should be one of the STAT_... constants
wire pc:64;               # put the address of the next instruction into this

wire reg_srcA:4, reg_srcB:4;        # use to pick which program registers to read from
wire reg_dstE:4, reg_dstM:4;        # use to pick which program registers to write to
wire reg_inputE:64, reg_inputM:64;  # use to provide values to write to program registers

wire mem_writebit:1, mem_readbit:1; # set at most one of these two to 1 to access memory
wire mem_addr:64;                   # if accessing memory, put the address accessed here
wire mem_input:64;                  # if writing to memory, put the value to write here

### fixed-functionality outputs (things you should use but not assign to)

wire i10bytes:80;                     # output value of instruction read; linked to pc
wire reg_outputA:64, reg_outputB:64;  # values from registers; linked to reg_srcA and reg_srcB
wire mem_output:64;                   # value read from memory; linked to mem_readbit and mem_addr

####################### end builtin signals ###########################

# An example file in our custom HCL variant, with lots of comments
#Gabriel Groover (gtg3vv)

register pP {  
    # our own internal register. P_pc is its output, p_pc is its input.
	pc:64 = 0; # 64-bits wide; 0 is its default value.
	
	# we could add other registers to the P register bank
	# register bank should be a lower-case letter and an upper-case letter, in that order.
	
	# there are also two other signals we can optionally use:
	# "bubble_P = true" resets every register in P to its default value
	# "stall_P = true" causes P_pc not to change, ignoring p_pc's value
} 

register cC {
    SF:1 = 0;
    ZF:1 = 0;
};

# we can define our own input/output "wires" of any number of 0<bits<=80
wire opcode:8, icode:4,ifun:4,regB:4,regA:4,valC:64,valE:64;
wire conditionsMet:1;

# the x[i..j] means "just the bits between i and j".  x[0..1] is the 
# low-order bit, similar to what the c code "x&1" does; "x&7" is x[0..3]
opcode = i10bytes[0..8];   # first byte read from instruction memory
icode = opcode[4..8];      # top nibble of that byte
ifun = i10bytes[0..4];
valC = [
    icode == JXX : i10bytes[8..72];
    1 : i10bytes[16..80];
    ];
regB = i10bytes[8..12];
regA = i10bytes[12..16];

reg_dstE = [
    !conditionsMet && icode == CMOVXX : REG_NONE;
    icode in {OPQ,IRMOVQ,RRMOVQ}: regB;
    1 : REG_NONE;
];

conditionsMet = [
    ifun == LE : C_SF || C_ZF;
    ifun == LT : C_SF;
    ifun == EQ : C_ZF;
    ifun == NE : !C_ZF;
    ifun == GE : !C_SF || C_ZF;
    ifun == GT : !C_SF;
    ifun == ALWAYS : 1;
    1 : 0;
];

reg_srcA = regA;
reg_srcB = regB;

reg_inputE = [ 
    icode == RRMOVQ : reg_outputA;
    icode == IRMOVQ : valC;
    icode == OPQ : valE;
    1 : 0;
];

valE = [
    icode == OPQ && ifun == ADDQ : reg_outputA + reg_outputB;
    icode == OPQ && ifun == SUBQ : reg_outputB - reg_outputA; 
    icode == OPQ && ifun == ANDQ : reg_outputA & reg_outputB; 
    icode == OPQ && ifun == XORQ : reg_outputA ^ reg_outputB;
    icode == RMMOVQ : reg_outputB + valC;
    1 : 0;

];
stall_C = (icode != OPQ);
c_ZF = (valE == 0);
c_SF = (valE >= 0x8000000000000000);

mem_addr = valE;
mem_input = reg_outputA;
mem_writebit = [
    icode == RMMOVQ : 1;
    1 : 0;
];
mem_readbit = 0;


/* we could also have done i10bytes[4..8] directly, but I wanted to
 * demonstrate more bit slicing... and all 3 kinds of comments      */
// this is the third kind of comment

# named constants can help make code readable
const TOO_BIG = 0xC; # the first unused icode in Y86-64

# some named constants are built-in: the icodes, ifuns, STAT_??? and REG_???


# Stat is a built-in output; STAT_HLT means "stop", STAT_AOK means 
# "continue".  The following uses the mux syntax described in the 
# textbook
Stat = [
	icode == HALT : STAT_HLT;
	icode >= 0xb  : STAT_INS;
	1             : STAT_AOK;
];

# to make progress, we have to update the PC...
p_pc = [
    icode == RRMOVQ || icode == OPQ || icode == CMOVXX || icode == PUSHQ ||
    icode == POPQ : P_pc + 2;
    icode == IRMOVQ || icode == RMMOVQ || icode == MRMOVQ : P_pc + 10;
    icode == CALL : P_pc + 9;
    icode == JXX : valC;
    1 : P_pc + 1;
];# you may use math ops directly...

# "pc" is a pre-defined input to the instruction memory and is the 
# address to fetch 6 bytes from (into pre-defined output "i10bytes").
pc = P_pc;
++++++++++++++++++ generated from the preceeding HCL ++++++++++++++++++/




/////////////////////// int type bigger than long ///////////////////
private template negOneList(uint length) {
	static if (length == 1) enum negOneList = "-1";
	else enum negOneList = negOneList!(length-1)~", -1";
}

struct bvec(uint bits) if (bits != 0) {
	static enum words = (bits+31)/32;
	static enum min = bvec.init;
	mixin("static enum max = bvec(["~negOneList!words~"]);");
	uint[words] data;
	ubyte *data_bytes() { return cast(ubyte*)&(this.data[0]); }

	this(uint x) { data[0] = x; truncate; }
	this(ulong x) { data[0] = cast(uint)x; static if (words > 1) data[1] = cast(uint)(x>>32); truncate; }
	this(uint[] dat) { this.data[] = dat[]; truncate; }
	this(uint o)(bvec!o x) if (o < bits) { data[0..x.words] = x.data[]; truncate; }
	this(uint o)(bvec!o x) if (o > bits) { data[] = x.data[0..words]; truncate; }
	
	ref bvec opAssign(uint x) { data[0] = x; static if(words > 1) data[1..$] = 0; return truncate; }
	ref bvec opAssign(ulong x) { data[0] = cast(uint)x; static if (words > 1) data[1] = cast(uint)(x>>32); static if(words > 2) data[2..$] = 0; return truncate; }
	ref bvec opAssign(uint[] dat) { this.data[] = dat[]; return truncate; }
	ref bvec opAssign(uint o)(bvec!o x) if (o < bits) { data[0..x.words] = x.data[]; static if (x.words < words) data[x.words..$] = 0; return truncate; }
	ref bvec opAssign(uint o)(bvec!o x) if (o > bits) { data[] = x.data[0..words]; return truncate; }

	ref bvec truncate() {
		static if ((bits&31) != 0) {
			data[$-1] &= 0xffffffffU >> (32-(bits&31));
		}
		return this;
	}
	bvec!(bits+b1) cat(uint b2)(bvec!b2 other) {
		bvec!(bits+b1) ans;
		foreach(i,v; data) ans.data[i] = v;
		static if ((bits&31) == 0) {
			foreach(i,v; other.data) ans.data[i+words] = v;
		} else {
			foreach(i,v; other.data) {
				ans.data[i+words-1] |= (v<<(bits&31));
				if (i+words < ans.words) ans.data[i+words] = (v>>(32-(bits&31)));
			}
		}
		return ans;
	}
	bvec!(e-s) slice(uint s, uint e)() if (s <= e && e <= bits) {
		bvec!(e-s) ans;
		static if ((s&31) == 0) {
			ans.data[] = data[s/32 .. s/32+ans.words];
		} else {
			foreach(i; s/32..((e-s)+31)/32) {
				ans.data[i-s/32] = data[i]>>(s&31);
				if(i > s/32) ans.data[i-s/32-1] |= data[i]<<(32-(s&31));
			}
		}
		return ans.truncate;
	}
	string hex() {
		import std.format, std.range;
		static if (words > 0) {
			return format("%0"~format("%d",((bits&31)+3)/4)~"x%(%08x%)", data[$-1], retro(data[0..$-1]));
		} else {
			return format("%0"~format("%d",(bits+3)/4)~"x", data[0]);
		}
	}
	string smallhex() {
		auto ans = hex;
		while (ans.length > 1 && ans[0] == '0') ans = ans[1..$];
		return ans;
	}
	version (BigEndian) {
		pragma(msg, "hexbytes not implemented on big endian hardware");
	} else {
		string hexbytes() {
			import std.format;
			return format("%(%02x%| %)", data_bytes[0..((bits+7)/8)]);
		}
	}
	string toString() {
		return "0x"~smallhex;
	}
	string bin() {
		import std.format, std.range;
		ubyte[words*4] tmp = *(cast(ubyte[words*4]*)&data);
		static if (bits <= 8) {
			return format("%0"~format("%d",bits)~"b", tmp[0]);
		} else static if ((bits&7) != 0) {
			return format("%0"~format("%d",bits&7)~"b_%(%08b%|_%)", tmp[(bits-1)/8], retro(tmp[0..(bits-1)/8]));
		} else {
			return format("%(%08b%|_%)", retro(tmp[0..bits/8]));
		} 
	}
	static bvec hex(string s)
	in {
		assert(s.length <= (bits+3)/4, "too many hex digits for this type");
		foreach(c; s) assert((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'), "expected a raw hex string");
		if (s.length > bits/4) assert(s[0]-'0' < (1<<(bits&3)), "most-significant digit too big for this type");
	} body {
		uint place = 0, shift = 0;
		bvec ans;
		foreach_reverse(c; s) {
			uint val = c - (c < 'Z' ? c < 'A' ? '0' : 'A'-10 : 'a'-10);
			ans.data[place] |= shift ? val<<shift : val;
			shift += 4;
			place += shift>=32;
			shift &= 31;
		}
		return ans; // no need to truncate; the in conditions take care of that
	}
	
	bool getBit(uint i) pure nothrow {
		return i >= bits ? false 
			: ((0==(i&31)) ? data[i/32]&1 : data[i/32]&(1<<(i&31))) != 0; 
	}
	
	ref bvec setBit(uint i, bool v) pure nothrow
	in { assert(i < bits, "illegal bit index"); }
	body { 
		if (v) if (0==(i&31)) data[i/32]|=1;
		       else           data[i/32]|=(1<<(i&31));
		else if (0==(i&31)) data[i/32]&=~1;
		     else           data[i/32]&=~(1<<(i&31));
		return this;
	}
	
	int opCmp(T)(T x) if (is(T : uint)) {
		foreach(i; 1..data.length) if (data[i] != 0) return 1;
		return data[0] < x ? -1 : data[0] == x ? 0 : 1;
	}
	int opCmp(uint b2)(bvec!b2 x) {
		static if (x.words == words) {
			foreach_reverse(i; 0..x.words) if (data[i] != x.data[i]) return data[i] < x.data[i] ? -1 : 1;
			return 0;
		} else static if (x.words < words) {
			foreach(i; x.words..words) if (data[i] != 0) return 1;
			foreach_reverse(i; 0..x.words) if (data[i] != x.data[i]) return data[i] < x.data[i] ? -1 : 1;
			return 0;
		} else {
			foreach(i; words..x.words) if (x.data[i] != 0) return -1;
			foreach_reverse(i; 0..words) if (data[i] != x.data[i]) return data[i] < x.data[i] ? -1 : 1;
			return 0;
		}
	}
	bool opEquals(T)(T x) { return this.opCmp(x) == 0; }
	T opCast(T)() if (is(T == bool)) { return opCmp!uint(0) != 0; }
	T opCast(T)() if (is(T == ulong)) { 
		static if (words > 1) return ((cast(ulong)data[1])<<32) | data[0];
		return data[0];
	}
	T opCast(T)() if (is(T == uint)) { return data[0]; }
	
	ref bvec opOpAssign(string op)(bvec s) pure nothrow if (op == "<<" || op == ">>") {
		if (s >= bits) data[] = 0;
		return this.opOpAssign!s(data[0]);
	}
	ref bvec opOpAssign(string op)(ulong s) pure nothrow if (op == "<<" || op == ">>") {
		return opOpAssign!op(cast(uint)s);
	}
	ref bvec opOpAssign(string op)(uint s) pure nothrow if (op == "<<") {
		if (s >= bits) data[] = 0;
		else {
			if (s >= 32) {
				auto ds = s/32;
				s &= 31;
				data[ds..$] = data[0..$-ds].dup;
				data[0..ds] = 0;
			}
			if (s != 0)
				foreach_reverse(i; 0..words)
					data[i] = (data[i]<<s) | (i > 0 ? data[i-1]>>(32-s) : 0);
		}
		return this.truncate;
	}
	ref bvec opOpAssign(string op)(uint s) pure nothrow if (op == ">>") {
		if (s >= bits) data[] = 0;
		else {
			if (s >= 32) {
				auto ds = s/32;
				s &= 31;
				data[0..$-ds] = data[ds..$].dup;
				data[$-ds..$] = 0;
			}
			if (s != 0)
				foreach(i; 0..words)
					data[i] = (data[i]>>s) | (i+1 < data.length ? data[i+1]<<(32-s) : 0);
		}
		return this.truncate;
	}
	ref bvec opOpAssign(string op)(bvec x) pure nothrow if (op == "&" || op == "|" || op == "^") {
		foreach(i,ref v; this.data) mixin("v "~op~"= x.data[i];");
		return this.truncate;
	}
	ref bvec opOpAssign(string s)(bvec x) pure nothrow if (s == "+" || s == "-") {
		ulong carry = s == "+" ? 0 : 1;
		foreach(i, ref v; data) {
			carry += v;
			carry += s == "+" ? x.data[i] : ~x.data[i];
			v = cast(uint)carry;
			carry >>= 32;
		}
		return this.truncate;
	}
	ref bvec opOpAssign(string op)(bvec x) pure nothrow if (op == "*") {
		bvec ans;
		ulong carry = 0;
		foreach(digit; 0..words) {
			ulong accum = carry&uint.max;
			carry >>= 32;
			foreach(i; 0..digit+1) {
				ulong tmp = data[i] * cast(ulong)x.data[digit-i];
				accum += tmp&uint.max;
				carry += tmp>>32;
			}
			ans.data[digit] = cast(uint)accum;
			carry += accum>>32;
		}
		this.data[] = ans.data[];
		return this.truncate;
	}
	ref bvec opOpAssign(string s)(bvec div) pure nothrow if (s == "/" || s == "%") {
		import std.stdio;
		bvec rem = this;
		bvec num;
		uint place = 0;
		while (div < rem && !div.getBit(bits-1)) { place += 1; div <<= 1; }
		while (true) {
			if (rem >= div) {
				num.setBit(place, true);
				rem -= div;
			}
			if (place == 0) break;
			div >>= 1;
			place -= 1;
		}
		static if (s == "/") this.data[] = num.data[];
		else this.data[] = rem.data[];
		return this;
	}
	ref bvec opOpAssign(string s)(ulong x) pure nothrow if (s != "<<" && s != ">>") {
		return this.opOpAssign!s(bvec(x));
	}
	ref bvec opOpAssign(string s)(uint x) pure nothrow if (s != "<<" && s != ">>") {
		return this.opOpAssign!s(bvec(x));
	}

	bvec opUnary(string s)() pure nothrow if (s == "~") {
		bvec ans = this;
		foreach(i,ref v; ans.data) v ^= max.data[i];
		return ans;
	}
	bvec opUnary(string s)() pure nothrow if (s == "-") { bvec ans; ans -= this; return ans; }

	bvec opBinary(string op, T)(T x) if (__traits(compiles, this.opOpAssign!op(x))) {
		bvec ans = this; return ans.opOpAssign!op(x);
	}
}
unittest { bvec!10 x = [-1]; assert(x.data[0] == 0x3ff,"expected 0x3ff"); }
unittest { bvec!40 x = [-1,-1]; assert(x.data == [0xffffffffU,0xffu]); }
unittest { bvec!64 x = [-1,-1]; assert(x.data == [0xffffffffU,0xffffffffu]); }
unittest { 
	bvec!35 x = [0x40000000,0x2]; 
	assert((x>>1).data == [0x20000000,0x1]); 
	assert((x<<1).data == [0x80000000,0x4]); 
	assert((x<<2).data == [0x00000000,0x1]); 
}
unittest { 
	bvec!128 x = [0x4,0x40000000,0x2, 0x4]; 
	assert((x<<33).data == [0,0x8,0x80000000,0x4]); 
	assert((x>>33).data == [0x20000000,0x1,0x2,0]); 
}alias bvec!80 ulonger;


/////////////////////////// register file ///////////////////////////
ulong[15] __regfile = [0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0];

////////////////////////////// memory ///////////////////////////////
ubyte[ulong] __memory;
bool __can_read_imem(ulong mem_addr) { return mem_addr < ulong.max-10; }
bool __can_read_dmem(ulong mem_addr) { return mem_addr < ulong.max-8; }
bool __can_write_dmem(ulong mem_addr) { return mem_addr < ulong.max-8; }
ubyte[] __read_bytes(ulong baseAddr, uint bytes) {
    ubyte[] ans = new ubyte[bytes];
    foreach_reverse(i; 0..bytes) {
        if ((baseAddr + i) in __memory) ans[i] = __memory[baseAddr+i];
        else ans[i] = 0;
    }
    return ans;
}
ulong __asUlong(ubyte[] arg) {
    ulong ans = 0;
    foreach_reverse(i; 0..8) if (i < arg.length) {
        ans <<= 8;
        ans |= arg[i];
    }
    return ans;
}
ulonger __asUlonger(ubyte[] arg) {
    ulonger ans = 0;
    foreach_reverse(i; 0..10) if (i < arg.length) {
        ans <<= 8;
        ans |= arg[i];
    }
    return ans;
}
void __write_bytes(ulong baseAddr, ulong value, uint bytes) {
    foreach(i; 0..bytes) {
        __memory[baseAddr+i] = cast(ubyte)value;
        value >>= 8;
    }
}
ulonger __read_imem(ulong mem_addr) { return __asUlonger(__read_bytes(mem_addr, 10)); }
ulong __read_dmem(ulong mem_addr) { return __asUlong(__read_bytes(mem_addr, 8)); }
void __write_dmem(ulong mem_addr, ulong value) { __write_bytes(mem_addr, value, 8); }

//////////////// pipeline registers' initial values ////////////////
// register bank P:
bool _HCL_bubble_P = false;
bool _HCL_stall_P  = false;
ulong _HCL_P_pc = 0;
// register bank C:
bool _HCL_bubble_C = false;
bool _HCL_stall_C  = false;
ulong _HCL_C_ZF = 0;
ulong _HCL_C_SF = 0;

////////////////////////// disassembler /////////////////////////////

enum RNAMES = [ "%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi",
"%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "none"];
enum OPNAMES = [ "addq", "subq", "andq", "xorq", "op4", "op5", "op6", "op7",
"op8", "op9", "op10", "op11", "op12", "op13", "op14", "op15"];
enum JMPNAMES = [ "jmp", "jle", "jl", "je", "jne", "jge", "jg", "jXX",
"jXX", "jXX", "jXX", "jXX", "jXX", "jXX", "jXX", "jXX"];
enum RRMOVQNAMES = [ "rrmovq", "cmovle", "cmovl", "cmove", "cmovne", "cmovge", "cmovg", "cmovXX",
"cmovXX", "cmovXX", "cmovXX", "cmovXX", "cmovXX", "cmovXX", "cmovXX", "cmovXX"];
string disas(ulonger i10bytes) {
    auto b = i10bytes.data_bytes;
    auto s = i10bytes.hexbytes;
    switch((i10bytes.data[0]&0xf0)>>4) {
        case 0 : return s[0..3*1-1]~" : halt";
        case 1 : return s[0..3*1-1]~" : nop";
        case 2 : return s[0..3*2-1]~" : "~RRMOVQNAMES[b[0]&0xf]~" "~RNAMES[(b[1]>>4)&0xf]~", "~RNAMES[b[1]&0xf];
        case 3 : return s[0..3*10-1]~" : irmovq $0x"~(i10bytes.slice!(16,80).smallhex)~", "~RNAMES[b[1]&0xf];
        case 4 : return s[0..3*10-1]~" : rmmovq "~RNAMES[(b[1]>>4)&0xf]~", 0x"~(i10bytes.slice!(16,80).smallhex)~"("~RNAMES[b[1]&0xf]~")";
        case 5 : return s[0..3*10-1]~" : mrmovq 0x"~(i10bytes.slice!(16,80).smallhex)~"("~RNAMES[b[1]&0xf]~"), "~RNAMES[(b[1]>>4)&0xf];
        case 6 : return s[0..3*2-1]~" : "~OPNAMES[b[0]&0xf]~" "~RNAMES[(b[1]>>4)&0xf]~", "~RNAMES[b[1]&0xf];
        case 7 : return s[0..3*9-1]~" : "~JMPNAMES[b[0]&0xf]~" 0x"~(i10bytes.slice!(8,72).smallhex);
        case 8 : return s[0..3*9-1]~" : call  0x"~(i10bytes.slice!(8,72).smallhex);
        case 9 : return s[0..3*1-1]~" : ret";
        case 10 : return s[0..3*2-1]~" : pushq "~RNAMES[(b[1]>>4)&0xf];
        case 11 : return s[0..3*2-1]~" : popq "~RNAMES[(b[1]>>4)&0xf];
        default: return "unknown operation";
    }
}

////////////////////////// update cycle /////////////////////////////
int tick(bool showpc=true, bool showall=false) {
    ulong _HCL_mem_readbit = 0UL;
    _HCL_mem_readbit &= 0x1;
    if (showall) writefln("set mem_readbit to 0x%x",_HCL_mem_readbit);
    ulong _HCL_pc = _HCL_P_pc;
    _HCL_pc &= 0xffffffffffffffff;
    if (showall) writefln("set pc to 0x%x",_HCL_pc);
    ulonger _HCL_i10bytes = __read_imem(_HCL_pc);
    if (showpc) writef(`pc = 0x%x; `, _HCL_pc);
    if (showall || showpc) writefln(`loaded [%s]`, disas(_HCL_i10bytes));
    ulong _HCL_opcode = cast(ulong)(((_HCL_i10bytes)>>0UL)&0xff);
    _HCL_opcode &= 0xff;
    if (showall) writefln("set opcode to 0x%x",_HCL_opcode);
    ulong _HCL_icode = cast(ulong)(((_HCL_opcode)>>4UL)&0xf);
    _HCL_icode &= 0xf;
    if (showall) writefln("set icode to 0x%x",_HCL_icode);
    ulong _HCL_ifun = cast(ulong)(((_HCL_i10bytes)>>0UL)&0xf);
    _HCL_ifun &= 0xf;
    if (showall) writefln("set ifun to 0x%x",_HCL_ifun);
    ulong _HCL_valC = (((_HCL_icode)==(7)) ? (cast(ulong)(((_HCL_i10bytes)>>8UL)&0xffffffffffffffff)) :
		(cast(ulong)(((_HCL_i10bytes)>>16UL)&0xffffffffffffffff)));
    _HCL_valC &= 0xffffffffffffffff;
    if (showall) writefln("set valC to 0x%x",_HCL_valC);
    ulong _HCL_regB = cast(ulong)(((_HCL_i10bytes)>>8UL)&0xf);
    _HCL_regB &= 0xf;
    if (showall) writefln("set regB to 0x%x",_HCL_regB);
    ulong _HCL_regA = cast(ulong)(((_HCL_i10bytes)>>12UL)&0xf);
    _HCL_regA &= 0xf;
    if (showall) writefln("set regA to 0x%x",_HCL_regA);
    ulong _HCL_conditionsMet = (((_HCL_ifun)==(1)) ? ((_HCL_C_SF)||(_HCL_C_ZF)) :
		((_HCL_ifun)==(2)) ? (_HCL_C_SF) :
		((_HCL_ifun)==(3)) ? (_HCL_C_ZF) :
		((_HCL_ifun)==(4)) ? (!_HCL_C_ZF) :
		((_HCL_ifun)==(5)) ? ((!_HCL_C_SF)||(_HCL_C_ZF)) :
		((_HCL_ifun)==(6)) ? (!_HCL_C_SF) :
		((_HCL_ifun)==(0)) ? (1UL) :
		(0UL));
    _HCL_conditionsMet &= 0x1;
    if (showall) writefln("set conditionsMet to 0x%x",_HCL_conditionsMet);
    ulong _HCL_reg_srcA = _HCL_regA;
    _HCL_reg_srcA &= 0xf;
    if (showall) writefln("set reg_srcA to 0x%x",_HCL_reg_srcA);
    ulong _HCL_reg_srcB = _HCL_regB;
    _HCL_reg_srcB &= 0xf;
    if (showall) writefln("set reg_srcB to 0x%x",_HCL_reg_srcB);
    _HCL_stall_C = cast(bool)(((_HCL_icode)!=(6)));
    if (showall) writefln("set stall_C to %s",_HCL_stall_C);
    ulong _HCL_mem_writebit = (((_HCL_icode)==(4)) ? (1UL) :
		(0UL));
    _HCL_mem_writebit &= 0x1;
    if (showall) writefln("set mem_writebit to 0x%x",_HCL_mem_writebit);
    ulong _HCL_Stat = (((_HCL_icode)==(0)) ? (2) :
		((_HCL_icode)>=(0xbUL)) ? (4) :
		(1));
    _HCL_Stat &= 0x7;
    if (showall) writefln("set Stat to 0x%x",_HCL_Stat);
    ulong _HCL_p_pc = (((((((_HCL_icode)==(2))||((_HCL_icode)==(6)))||((_HCL_icode)==(2)))||((_HCL_icode)==(10)))||((_HCL_icode)==(11))) ? ((_HCL_P_pc)+(2UL)) :
		((((_HCL_icode)==(3))||((_HCL_icode)==(4)))||((_HCL_icode)==(5))) ? ((_HCL_P_pc)+(10UL)) :
		((_HCL_icode)==(8)) ? ((_HCL_P_pc)+(9UL)) :
		((_HCL_icode)==(7)) ? (_HCL_valC) :
		((_HCL_P_pc)+(1UL)));
    _HCL_p_pc &= 0xffffffffffffffff;
    if (showall) writefln("set p_pc to 0x%x",_HCL_p_pc);
    ulong _HCL_reg_outputA = _HCL_reg_srcA < __regfile.length ? __regfile[cast(size_t)_HCL_reg_srcA] : 0;
    if (showall && _HCL_reg_srcA < __regfile.length) writefln("because reg_srcA was set to %x (%s), set reg_outputA to 0x%x", _HCL_reg_srcA, RNAMES[cast(size_t)_HCL_reg_srcA], _HCL_reg_outputA);
    ulong _HCL_reg_outputB = _HCL_reg_srcB < cast(ulong)__regfile.length ? __regfile[cast(size_t)_HCL_reg_srcB] : 0;
    if (showall && _HCL_reg_srcB < __regfile.length) writefln("because reg_srcB was set to %x (%s), set reg_outputB to 0x%x", _HCL_reg_srcB, RNAMES[cast(size_t)_HCL_reg_srcB], _HCL_reg_outputB);
    ulong _HCL_reg_dstE = (((!_HCL_conditionsMet)&&((_HCL_icode)==(2))) ? (15) :
		(((((_HCL_icode)==(6)))||(((_HCL_icode)==(3))))||(((_HCL_icode)==(2)))) ? (_HCL_regB) :
		(15));
    _HCL_reg_dstE &= 0xf;
    if (showall) writefln("set reg_dstE to 0x%x",_HCL_reg_dstE);
    ulong _HCL_valE = ((((_HCL_icode)==(6))&&((_HCL_ifun)==(0))) ? ((_HCL_reg_outputA)+(_HCL_reg_outputB)) :
		(((_HCL_icode)==(6))&&((_HCL_ifun)==(1))) ? ((_HCL_reg_outputB)-(_HCL_reg_outputA)) :
		(((_HCL_icode)==(6))&&((_HCL_ifun)==(2))) ? ((_HCL_reg_outputA)&(_HCL_reg_outputB)) :
		(((_HCL_icode)==(6))&&((_HCL_ifun)==(3))) ? ((_HCL_reg_outputA)^(_HCL_reg_outputB)) :
		((_HCL_icode)==(4)) ? ((_HCL_reg_outputB)+(_HCL_valC)) :
		(0UL));
    _HCL_valE &= 0xffffffffffffffff;
    if (showall) writefln("set valE to 0x%x",_HCL_valE);
    ulong _HCL_c_ZF = ((_HCL_valE)==(0UL));
    _HCL_c_ZF &= 0x1;
    if (showall) writefln("set c_ZF to 0x%x",_HCL_c_ZF);
    ulong _HCL_c_SF = ((_HCL_valE)>=(0x8000000000000000UL));
    _HCL_c_SF &= 0x1;
    if (showall) writefln("set c_SF to 0x%x",_HCL_c_SF);
    ulong _HCL_mem_addr = _HCL_valE;
    _HCL_mem_addr &= 0xffffffffffffffff;
    if (showall) writefln("set mem_addr to 0x%x",_HCL_mem_addr);
    ulong _HCL_mem_input = _HCL_reg_outputA;
    _HCL_mem_input &= 0xffffffffffffffff;
    if (showall) writefln("set mem_input to 0x%x",_HCL_mem_input);
    ulong _HCL_mem_output = _HCL_mem_readbit ? __read_dmem(_HCL_mem_addr) : 0;
    if (showall && _HCL_mem_readbit) writefln("because mem_readbit was 1, set mem_output to 0x%x by reading memory from mem_addr (0x%x)", _HCL_mem_output, _HCL_mem_addr);
    if (_HCL_mem_writebit) __write_dmem(_HCL_mem_addr, _HCL_mem_input);
    if (showall && _HCL_mem_writebit) writefln("because mem_writebit was 1, set memory at mem_addr (0x%x) to mem_input (0x%x)", _HCL_mem_addr, _HCL_mem_input);
    ulong _HCL_reg_inputE = (((_HCL_icode)==(2)) ? (_HCL_reg_outputA) :
		((_HCL_icode)==(3)) ? (_HCL_valC) :
		((_HCL_icode)==(6)) ? (_HCL_valE) :
		(0UL));
    _HCL_reg_inputE &= 0xffffffffffffffff;
    if (showall) writefln("set reg_inputE to 0x%x",_HCL_reg_inputE);
    if (_HCL_reg_dstE < __regfile.length) { __regfile[cast(size_t)_HCL_reg_dstE] = cast(ulong)_HCL_reg_inputE; }
    if (showall && _HCL_reg_dstE < __regfile.length) writefln("wrote reg_inputE (0x%x) to register reg_dstE (%x, which is %s)", _HCL_reg_inputE, _HCL_reg_dstE, RNAMES[cast(size_t)_HCL_reg_dstE]);

	 // rising clock edge: lock register writes
    if (_HCL_bubble_P) _HCL_P_pc = 0;
    else if (!_HCL_stall_P) _HCL_P_pc = _HCL_p_pc;
    if (_HCL_bubble_C) _HCL_C_ZF = 0;
    else if (!_HCL_stall_C) _HCL_C_ZF = _HCL_c_ZF;
    if (_HCL_bubble_C) _HCL_C_SF = 0;
    else if (!_HCL_stall_C) _HCL_C_SF = _HCL_c_SF;
	pragma(msg,`INFO: did not specify reg_dstM; disabling register write port M`);

	return cast(int)_HCL_Stat;
}
pragma(msg,`Estimated clock delay: 98`);
enum tpt = 98;

import std.stdio, std.file, std.string, std.conv, std.algorithm;
int main(string[] args) {
    bool verbose = true;
    bool pause = false;
    bool showall = false;
    uint maxsteps = 10000;
    string fname;
    foreach(a; args[1..$]) {
        if      (a == "-i" || a == "--interactive") pause   = true;
        else if (a == "-d" || a == "--debug"      ) showall = true;
        else if (a == "-q" || a == "--quiet"      ) verbose = false;
        else if (exists(a)) {
            if (fname.length > 0)
                writeln("WARNING: multiple files; ignoring \"",a,"\" in preference of \"",fname,"\"");
            else
                fname = a;
        } else if (a[0] > '0' && a[0] <= '9') {
            maxsteps = to!uint(a);
        } else {
            writeln("ERROR: unexpected argument \"",a,"\"");
            return 1;
        }
    }
    if (showall && !verbose) {
        writeln("ERROR: cannot be in both quiet and debug mode");
        return 2;
    }
    if (fname.length == 0) {
        writeln("USAGE: ",args[0]," [options] somefile.yo");
        writeln("Options:");
        writefln("    [a number]       : time out after that many steps (default: %d)",maxsteps);
        writeln("    -i --interactive : pause every clock cycle");
        writeln("    -q --quiet       : only show final state");
        writeln("    -d --debug       : show every action during simulation");
        return 3;
    }
    // load .yo input
    auto f = File(fname,"r");
    foreach(string line; lines(f)) {
        // each line is 0xaddress : hex data | junk, or just junk
        // fixed width:
        //     01234567890123456789012345678...
        //     0x000: 30f40001000000000000 |    irmovq $0x100,%rsp  # Initialize stack pointer
        if (line[0..2] == "0x") {
            auto address = to!uint(line[2..5], 16);
            auto datas = line[7..27].strip;
            for(uint i=0; i < datas.length; i += 2) {
                __memory[address+(i>>1)] = to!ubyte(datas[i..i+2],16);
            }
        }
    }

    void dumpstate() {
        writefln("| RAX: % 16x   RCX: % 16x   RDX: % 16x |", __regfile[0], __regfile[1], __regfile[2]);
        writefln("| RBX: % 16x   RSP: % 16x   RBP: % 16x |", __regfile[3], __regfile[4], __regfile[5]);
        writefln("| RSI: % 16x   RDI: % 16x   R8:  % 16x |", __regfile[6], __regfile[7], __regfile[8]);
        writefln("| R9:  % 16x   R10: % 16x   R11: % 16x |", __regfile[9], __regfile[10], __regfile[11]);
        writefln("| R12: % 16x   R13: % 16x   R14: % 16x |", __regfile[12], __regfile[13], __regfile[14]);

	write(`| register pP(`,(_HCL_bubble_P?'B':_HCL_stall_P?'S':'N'));
		writefln(`) { pc=%016x }                                |`, _HCL_P_pc);


	write(`| register cC(`,(_HCL_bubble_C?'B':_HCL_stall_C?'S':'N'));
		writefln(`) { SF=%01x ZF=%01x }                                          |`, _HCL_C_SF, _HCL_C_ZF);

        auto set = __memory.keys; sort(set);
        writeln("| used memory:   _0 _1 _2 _3  _4 _5 _6 _7   _8 _9 _a _b  _c _d _e _f    |");
        ulong last = 0;
        foreach(a; set) {
            if (a >= last) {
                last = ((a>>4)<<4);
                writef("|  0x%07x_:  ", last>>4);
                foreach(j; 0..16) {
                    if (last+j in __memory) { writef(" %02x", __memory[last+j]); }
                    else write("   ");
                    if (j == 7) write("  ");
                    if (j == 3 || j == 11) write(" ");
                }
                writeln("    |");
                if (last + 16 < last) break;
                last += 16;
            }
        }
    }
    
    // loop, possibly pausing
    foreach(i; 0..maxsteps) {
        if (verbose) {
            writefln("+------------------- between cycles %4d and %4d ----------------------+", i, i+1);
            dumpstate();
            writeln("+-----------------------------------------------------------------------+");
            if (pause) {
                write("(press enter to continue)");
                stdin.readln();
            }
        }
        auto code = tick(verbose, showall);
        if (code == 2) {
            writeln("+----------------------- halted in state: ------------------------------+");
            dumpstate();
            writeln("+--------------------- (end of halted state) ---------------------------+");
            writeln("Cycles run: ",i+1);
            writeln("Time used: ", (i+1)*tpt);
            return 0;
        }
        if (code > 2) {
            writeln("+------------------- error caused in state: ----------------------------+");
            dumpstate();
            writeln("+-------------------- (end of error state) -----------------------------+");
            writeln("Cycles run: ",i+1);
            writeln("Time used: ", (i+1)*tpt);
            write("Error code: ", code);
            if (code < 6) writeln(" (", ["Bubble","OK","Halt","Invalid Address", "Invalid Instruction", "Pipeline Error"][code],")");
            else writeln(" (user-defined status code)");
            return 0;
        }
    }
    writefln("+------------ timed out after %5d cycles in state: -------------------+", maxsteps);
    dumpstate();
    writeln("+-----------------------------------------------------------------------+");
    
    return 0;
}
